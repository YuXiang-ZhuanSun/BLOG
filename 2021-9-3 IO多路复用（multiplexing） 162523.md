# IO多路复用（multiplexing）

> 当一个服务器连接了1,000,000个用户的时候，不可能开1,000,000个进程（或线程）去处理，CPU核心太少了，大量上下文切换太费资源了。
>
> 只能想办法用一个线程去循环处理非常多的用户。但对于弱鸡编程者来说，自己写多用户IO循环处理太难了。所以前人总结经验，给了接口。

IO多路复用接口的过程：

* 一个线程，大量的socket连接，我们调用IO多路复用接口，程序就会阻塞起来。
* 当有socket连接发来信息的时候，程序会被唤醒，同时IO多路复用接口会返回”是哪些socket连接发来了信息“。
* 然后你就可以写程序来专门处理这些socket的信息了

## 回顾各类服务器，引入IO多路复用

服务器和一个用户建立了连接，需要读用户的请求，发回一些回复，再收一些请求，再回复......

服务器怎么等用户的请求呢？

### Block IO  ->多进程/多线程服务器

服务器主程序read阻塞，等用户发请求。如果还有其他用户发请求怎么办？

如果想阻塞等待请求，还想处理过个用户，就只有开新的进程或者新的线程了。

多进程和多线程有少许区别和联系，稍微辨析一下：

* 多进程的开销比多线程大。进程需要占用的内存更多，进程切换比线程切换更慢
* 多进程地址空间彼此独立，通信较困难。多线程之间，分享全局变量和堆空间，共享数据十分方便，当然，要注意同步。
* 多进程中一个进程挂了，其他进程可以继续运行。多线程一个线程挂了，其他线程都挂了。多进程更健壮一些。

但是当同时在线用户数量达到1,000,000，开1,000,000个进程（或线程）显然是不可想象的----CPU核心非常少，线程太多了，大量线程在等待，来不及执行，

线程疯狂切换，消耗大量资源。

那如果我们不阻塞呢?使用不阻塞IO?

### Nonblock IO ->事件驱动(event driven)服务器

服务器主程序read不阻塞，暴力循环所有用户，有需求就处理，没需求就下一个，如此不断循环。代码表述：

```c
while(1)
{
    //新用户加入
    cfd = accept(lfd);
    if(cfd > 0){
        fcntl(...);//设置为非阻塞
        fds.push_back(cfd);
    }
    for(fd in fds){
        len = read(fd);
        if(len>0){
            //处理用户逻辑
        }
    }
}
```

但这样搞也有很多缺点

* 明明没有来socket消息，CPU还要继续不断继续空转，这太浪费CPU资源了。
* 加入有1,000,000个用户，疯狂地循环一遍加上处理，等好几秒，延迟太大了。

为了解决这些问题，IO多路复用技术，闪亮登场。

### IO多路复用技术的理念与最底层原理

一个线程，1,000,000个在线用户，如何应对呢？系统提供了IO多路复用接口。这些接口的最核心想法就是：

* 在这些用户sockfd中，都注册上等待（即**把当前进程加入到这些sockfd文件的睡眠等待序列上，当信息来的时候，序列就会唤醒**）。

* 然后让本进程休眠。

* 一旦有sockfd来信息，就会唤醒本进程。然后把这个sockfd标记下来（然后扫一遍，看还有没有其他sockfd来信息的，都记下来，一块）返回去。

上述括号内待查证

